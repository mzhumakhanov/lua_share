ОПИСАНИЕ:
=========

Комплект состоит из библиотеки lua_share.dll и файла lua_share_boot.lua. Для корректной работы оба файла должны 
находиться в одном каталоге. Если файл lua_share_boot.lua отсутствует, то библиотека ведет себя несколько иначе, 
но тоже работает, о чем ниже.


инициализация:
--------------

package.cpath = getScriptPath() .. "\\lua_share.dll"
sh = require "share"


запись и чтение:
----------------

sh["hello"] = "world" -- запись
val = sh["hello"]     -- чтение


пространства имен:
------------------

local ns = sh.GetNameSpace("test_name_space")  -- создать пространство имен test_name_space
ns["hello"] = "world" -- запись 
val = ns["hello"]     -- чтение


получение снапшота:
-------------------

local ns = sh.GetNameSpace("test_name_space")  -- создать пространство имен test_name_space
ns["hello"] = "hello" -- 1 значение
ns["world"] = "world" -- 2 значение
val = ns:DeepCopy() -- получение снапшота


"bootstrap":
------------

Файл lua_share_boot.lua содержит код, который кастомизирует поведение хранилища. В текущей реализации 
используется  сравнение таблиц по содержимому. Например:

local ns = sh.GetNameSpace("test_name_space")
ns[{1, 2, {3, 4}}] = "JOHN"
ns[{1, 2, {3, 4}}] = "DOE"
tmp = ns[{1, 2, {3, 4}}]

Если файл lua_share_boot.lua существует, то в результате значение tmp будет содержать только строку 
"DOE", иначе обе строки: "JOHN" и "DOE",  так как ключи {1, 2, {3, 4}} - это deepcopy исходных ключей 
и разные объекты, хотя и с одинаковым содержимым, а по-умолчанию в lua сравниваются ссылки.

В lua_share_boot.lua можно запрограммировать свое поведение, а добавить свои метаметоды, например __gc. 
См комментарии в коде lua.


IPC:
----

Существует возможность создавать "удаленное" пространство имен, общие для нескольких запущенных приложений 
(терминалов QUIK). Для этого необходимо запустить сервер lua_share_server.exe, который хранит общие данные. 
Сервер запускает lua-скрипт, который хранится в файле lua_share_server.lua и который можно, при желании, 
кастомизировать. Общее хранилище существует, пока запущен сервер. Удаленное пространство имен создается 
следующим образом:

local ns = sh.GetIPCNameSpace("test_name_space")

Способ работы с ним не отличается.


pre-defined пространства:
-------------------------

"queues"    - пространство имен, реализующее очереди (queue).
"eventlist" - пространство, реализующее списки событий (аналог waitformultipleobjects).
"permanent" - пространство, загружающее себя из файла при старте и записывающее себя в файл при
              уничтожении.


примены:
--------

Примеры предназначены для запуска в терминале QUIK.

01_test_share_common.lua      - общий пример работы с lua_share

02_test_share_producer.lua    - пример скрипта "писатель" в цикле обновляет общие данные
03_test_share_consumer.lua    - пример скрипта "читатель" читает данные и выводит их в окно сообщений

04_test_share_tablekeys.lua   - демонстрация использования таблиц в качестве ключей хранилища

05_test_share_pushqueue.lua   - очереди: писатель
06_test_share_popqueue.lua    - очерели: читатель

07_test_share_pushevent.lua   - eventlist: писатель
08_test_share_popevent.lua    - eventlist: читатель

09_test_share_permanent.lua   - сохранение данных между запусками скрипта а так же перезапуском QUIK

10_test_share_IPC.lua         - пример работы с "удаленным" хранилищем, должен быть запущен lua_share.server.exe
